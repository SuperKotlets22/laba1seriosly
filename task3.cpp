#include <iostream>
#include <vector>
#include <string>
#include <utility> // Для swap (не используется в финальном коде, но было в оригинале)
#include <string.h> // Для memset
#include <numeric> // Опционально: Для gcd в C++17

using namespace std;

// Функция для вычисления Наибольшего Общего Делителя (НОД) с использованием алгоритма Евклида
// Гарантирует, что результат неотрицательный. Обрабатывает граничный случай gcd(0, 0) = 0.
long long gcd(long long n1, long long n2) {
    // Делаем входные данные неотрицательными для стандартного вычисления НОД
    if (n1 < 0) n1 = -n1;
    if (n2 < 0) n2 = -n2;

    while (n2 != 0) {
        long long temp = n1 % n2;
        n1 = n2;
        n2 = temp;
    }
    // n1 теперь содержит НОД. Он неотрицательный.
    return n1;
}

// Функция для целочисленного возведения в степень (base^exp)
// Вычисляет base в степени exp.
// Предполагается, что результат помещается в long long на основе ограничений задачи (a, b <= 10).
long long power(long long base, int exp) {
    long long res = 1;
    // Обрабатываем базовые случаи
    if (exp == 0) return 1; // Любое число^0 = 1 (включая 0^0 в этом контексте)
    if (base == 0) return 0; // 0^k = 0 для k > 0

    // Используем бинарное возведение в степень (возведение в степень путем возведения в квадрат) для эффективности
    long long current_base = base;
    int current_exp = exp;

    while (current_exp > 0) {
        if (current_exp % 2 == 1) {
            // Умножаем результат на текущее основание, если показатель степени нечетный
            // Базовую проверку на переполнение можно добавить здесь, если необходимо, но ограничения предполагают, что все в порядке
            res *= current_base;
        }
        // Делим показатель степени на 2
        current_exp /= 2;
        // Возводим основание в квадрат, если есть еще шаги
        if (current_exp > 0) {
            // Базовую проверку на переполнение можно добавить здесь
             current_base *= current_base;
        }
    }
    return res;
}

// Глобальный массив для хранения чисел Эйлера A(n, k)
// A[n][k] = количество перестановок {1, ..., n} с k подъемами.
// Размер 11x11 достаточен, так как максимальное 'a' равно 10.
long long A[11][11];

// Функция для вычисления чисел Эйлера до A(max_n, k) с использованием динамического программирования
void computeEulerian(int max_n) {
    // Инициализируем массив нулями
    memset(A, 0, sizeof(A));

    // Базовый случай: Пустая перестановка (n=0) имеет 0 элементов и 0 подъемов. A(0, 0) = 1.
    A[0][0] = 1;

    // Заполняем таблицу строка за строкой от n=1 до max_n
    for (int n = 1; n <= max_n; ++n) {
        // k представляет количество подъемов, от 0 до n-1
        for (int k = 0; k < n; ++k) {
            // Применяем рекуррентное соотношение:
            // A(n, k) = (n - k) * A(n - 1, k - 1) + (k + 1) * A(n - 1, k)
            // A(n-1, k-1) равно 0, если k-1 < 0 (т.е., k=0)

            long long term1 = 0;
            // Вклад от перестановок n-1 элементов с k-1 подъемами
            if (k > 0) {
                 term1 = (long long)(n - k) * A[n - 1][k - 1];
            }

            // Вклад от перестановок n-1 элементов с k подъемами
            long long term2 = (long long)(k + 1) * A[n - 1][k];

            // Вычисляем A(n, k). Предполагается, что сумма помещается в long long на основе ограничений.
            A[n][k] = term1 + term2;
        }
    }
}


int main() {
    // Оптимизируем операции ввода/вывода
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int a, b;
    // Читаем два целых числа
    if (!(cin >> a >> b)) {
         cerr << "Ошибка чтения ввода." << endl;
         return 1; // Указываем на ошибку ввода
    }

    // Проверяем ограничения ввода: a и b должны быть от 1 до 10 включительно
    if (a < 1 || a > 10 || b < 1 || b > 10) {
         cerr << "Входные значения должны быть от 1 до 10." << endl;
         return 1; // Указываем на неверный ввод
    }

    // Случай 1: Ряд расходится, если b = 1
    // Ряд становится Sum(n^a), который расходится, так как a >= 1.
    if (b == 1) {
        cout << "бесконечность" << endl;
    }
    // Случай 2: Ряд сходится, если b > 1
    // Известно, что сумма является рациональным числом.
    else {
        // Предварительно вычисляем числа Эйлера до A(a, k), необходимые для формулы суммы
        computeEulerian(a);

        // Вычисляем сумму по формуле, основанной на числах Эйлера:
        // Сумма = [ Sum_{j=0}^{a-1} A(a, j) * b^(a-j) ] / [ (b-1)^(a+1) ]

        long long numerator = 0;
        // Вычисляем числитель формулы суммы
        for (int j = 0; j < a; ++j) { // Индекс 'j' соответствует 'k' в A(a, k)
            // Вычисляем b в степени (a-j)
            long long term_power = power(b, a - j);
            // Умножаем на соответствующее число Эйлера A(a, j)
            // Предполагается, что произведение помещается в long long на основе ограничений
            long long term_product = A[a][j] * term_power;
            // Добавляем к общей сумме числителя
            // Предполагается, что сумма помещается в long long
            numerator += term_product;
        }

        // Вычисляем знаменатель формулы суммы: (b-1)^(a+1)
        // Предполагается, что результат помещается в long long
        long long denominator = power(b - 1, a + 1);

        // Знаменатель (b-1)^(a+1) всегда должен быть положительным и ненулевым, так как b > 1.
        if (denominator <= 0) {
             // Этого не должно произойти при заданных ограничениях, но проверяем для надежности
             cerr << "Внутренняя ошибка: Вычисление знаменателя не удалось или результат неположительный." << endl;
             return 1;
        }

        // Находим наибольший общий делитель (НОД) числителя и знаменателя
        // для упрощения дроби до несократимого вида.
        long long common = gcd(numerator, denominator);

        // Вычисляем упрощенный числитель (p) и знаменатель (q)
        long long p = numerator / common;
        long long q = denominator / common;

        // Выводим результат в виде несократимой дроби "p/q"
        cout << p << "/" << q << endl; 
    }

    return 0; // Указываем на успешное выполнение
}