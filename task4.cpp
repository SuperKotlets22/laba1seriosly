#include <iostream>
#include <vector>
#include <numeric>   // Для std::numeric_limits (очень большое/маленькое число)
#include <limits>    // Для std::numeric_limits
#include <algorithm> // Для std::max

using namespace std;

int main() {
    int n; // Количество элементов
    int m; // Максимальное количество элементов, которое можно взять за ход
    cin >> n >> m;

    vector<long long> a(n); // Вектор (массив) элементов
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }

    // prefix_sum[i] хранит сумму элементов a[0]...a[i-1]
    // Это как бы "накопленная сумма" до элемента i.
    vector<long long> prefix_sum(n + 1, 0);
    for (int i = 0; i < n; ++i) {
        prefix_sum[i + 1] = prefix_sum[i] + a[i];
    }
    // Теперь, чтобы узнать сумму от a[i] до a[j-1], можно просто сделать:
    // prefix_sum[j] - prefix_sum[i]

    // --- Динамическое программирование (основная логика) ---
    // dp[i] = максимальная РАЗНИЦА очков (мои очки - очки противника),
    //         которую я могу получить, если игра начинается с элемента a[i].
    vector<long long> dp(n + 1);

    // Базовый случай: если начинать с индекса n (массив пуст), разница равна 0.
    dp[n] = 0;

    // Идем с конца массива к началу (от i = n-1 до i = 0)
    for (int i = n - 1; i >= 0; --i) {

        // Мне нужно найти лучший ход из состояния i.
        // Я могу взять k элементов (от 1 до m).
        // Хочу выбрать такое k, чтобы итоговая разница dp[i] была максимальной.

        // Изначально считаем, что максимальная разница очень маленькая
        // (чтобы любое реальное значение было больше)
        long long max_diff_for_i = numeric_limits<long long>::min(); // Самое маленькое long long

        // Перебираем все возможные ходы: взять k элементов
        for (int k = 1; k <= m; ++k) {
            // Проверяем, не выходим ли мы за пределы массива
            int next_state_index = i + k; // Индекс, с которого начнет противник
            if (next_state_index > n) {
                break; // Если ход невозможен (берем слишком много), прекращаем пробовать больше k
            }

            // Считаем, сколько очков я получу за ЭТОТ ход (взяв k элементов с индекса i)
            long long score_this_turn = prefix_sum[next_state_index] - prefix_sum[i];

            // Узнаем, какую максимальную разницу получит ПРОТИВНИК,
            // начиная со следующего состояния (next_state_index). Это dp[next_state_index].
            long long opponent_best_diff = dp[next_state_index];

            // Моя итоговая разница, если я сделаю этот ход (возьму k элементов):
            // (очки за мой ход) - (лучшая разница противника со следующего хода)
            long long current_diff = score_this_turn - opponent_best_diff;

            // Обновляем максимальную разницу, которую я могу получить из состояния i
            max_diff_for_i = max(max_diff_for_i, current_diff);
        }

        // Записываем найденную лучшую разницу для состояния i
        dp[i] = max_diff_for_i;
    }

    // dp[0] хранит максимальную разницу, которую первый игрок (Павел)
    // может гарантировать себе с самого начала игры.
    if (dp[0] > 0) {
        cout << 1 << endl; // Если разница > 0, Павел выигрывает
    } else {
        cout << 0 << endl; // Иначе (разница <= 0), не может гарантировать выигрыш
    }

    return 0;
}