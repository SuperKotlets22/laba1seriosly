package main

import (
	"fmt"
	"os"
)

// Функция для вычисления Наибольшего Общего Делителя (НОД) с использованием алгоритма Евклида
// Гарантирует, что результат неотрицательный. Обрабатывает граничный случай gcd(0, 0) = 0.
func gcd(n1, n2 int64) int64 {
	// Делаем входные данные неотрицательными для стандартного вычисления НОД
	if n1 < 0 {
		n1 = -n1
	}
	if n2 < 0 {
		n2 = -n2
	}

	for n2 != 0 {
		n1, n2 = n2, n1%n2
	}
	// n1 теперь содержит НОД. Он неотрицательный.
	return n1
}

// Функция для целочисленного возведения в степень (base^exp)
// Вычисляет base в степени exp.
// Использует int64 для base и результата, exp может быть int64 (хотя в задаче он мал).
// Предполагается, что результат помещается в int64 на основе ограничений задачи (a, b <= 10).
func power(base, exp int64) int64 {
	var res int64 = 1
	// Обрабатываем базовые случаи
	if exp == 0 {
		return 1 // Любое число^0 = 1 (включая 0^0 в этом контексте)
	}
	if base == 0 {
		return 0 // 0^k = 0 для k > 0
	}

	// Используем бинарное возведение в степень (возведение в степень путем возведения в квадрат) для эффективности
	currentBase := base
	currentExp := exp

	for currentExp > 0 {
		if currentExp%2 == 1 {
			// Умножаем результат на текущее основание, если показатель степени нечетный
			// Базовую проверку на переполнение можно добавить здесь, если необходимо, но ограничения предполагают, что все в порядке
			res *= currentBase
		}
		// Делим показатель степени на 2
		currentExp /= 2
		// Возводим основание в квадрат, если есть еще шаги
		if currentExp > 0 {
			// Базовую проверку на переполнение можно добавить здесь
			currentBase *= currentBase
		}
	}
	return res
}

// Глобальный массив для хранения чисел Эйлера A(n, k)
// A[n][k] = количество перестановок {1, ..., n} с k подъемами.
// Размер 11x11 достаточен, так как максимальное 'a' равно 10.
// В Go массивы инициализируются нулями по умолчанию.
var A [11][11]int64

// Функция для вычисления чисел Эйлера до A(maxN, k) с использованием динамического программирования
func computeEulerian(maxN int) {
	// Базовый случай: Пустая перестановка (n=0) имеет 0 элементов и 0 подъемов. A(0, 0) = 1.
	A[0][0] = 1

	// Заполняем таблицу строка за строкой от n=1 до maxN
	for n := 1; n <= maxN; n++ {
		// k представляет количество подъемов, от 0 до n-1
		for k := 0; k < n; k++ {
			// Применяем рекуррентное соотношение:
			// A(n, k) = (n - k) * A(n - 1, k - 1) + (k + 1) * A(n - 1, k)
			// A(n-1, k-1) равно 0, если k-1 < 0 (т.е., k=0)

			var term1 int64 = 0
			// Вклад от перестановок n-1 элементов с k-1 подъемами
			if k > 0 {
				// Приводим типы к int64 для умножения
				term1 = int64(n-k) * A[n-1][k-1]
			}

			// Вклад от перестановок n-1 элементов с k подъемами
			// Приводим типы к int64 для умножения
			term2 := int64(k+1) * A[n-1][k]

			// Вычисляем A(n, k). Предполагается, что сумма помещается в int64 на основе ограничений.
			A[n][k] = term1 + term2
		}
	}
}

func main() {
	var a, b int

	// Читаем два целых числа
	_, err := fmt.Scan(&a, &b)
	if err != nil {
		fmt.Fprintln(os.Stderr, "Ошибка чтения ввода.", err)
		os.Exit(1) // Указываем на ошибку ввода
	}

	// Проверяем ограничения ввода: a и b должны быть от 1 до 10 включительно
	if a < 1 || a > 10 || b < 1 || b > 10 {
		fmt.Fprintln(os.Stderr, "Входные значения должны быть от 1 до 10.")
		os.Exit(1) // Указываем на неверный ввод
	}

	// Случай 1: Ряд расходится, если b = 1
	// Ряд становится Sum(n^a), который расходится, так как a >= 1.
	if b == 1 {
		fmt.Println("бесконечность")
	} else {
		// Случай 2: Ряд сходится, если b > 1
		// Известно, что сумма является рациональным числом.

		// Предварительно вычисляем числа Эйлера до A(a, k), необходимые для формулы суммы
		computeEulerian(a)

		// Вычисляем сумму по формуле, основанной на числах Эйлера:
		// Сумма = [ Sum_{j=0}^{a-1} A(a, j) * b^(a-j) ] / [ (b-1)^(a+1) ]

		var numerator int64 = 0
		// Вычисляем числитель формулы суммы
		for j := 0; j < a; j++ { // Индекс 'j' соответствует 'k' в A(a, k)
			// Вычисляем b в степени (a-j). Используем int64 для вычислений.
			termPower := power(int64(b), int64(a-j))
			// Умножаем на соответствующее число Эйлера A(a, j)
			// A[a][j] уже int64.
			termProduct := A[a][j] * termPower
			// Добавляем к общей сумме числителя
			numerator += termProduct
		}

		// Вычисляем знаменатель формулы суммы: (b-1)^(a+1)
		// Используем int64 для вычислений.
		denominator := power(int64(b-1), int64(a+1))

		// Знаменатель (b-1)^(a+1) всегда должен быть положительным и ненулевым, так как b > 1.
		if denominator <= 0 {
			// Этого не должно произойти при заданных ограничениях, но проверяем для надежности
			fmt.Fprintln(os.Stderr, "Внутренняя ошибка: Вычисление знаменателя не удалось или результат неположительный.")
			os.Exit(1)
		}

		// Находим наибольший общий делитель (НОД) числителя и знаменателя
		// для упрощения дроби до несократимого вида.
		common := gcd(numerator, denominator)

		// Вычисляем упрощенный числитель (p) и знаменатель (q)
		p := numerator / common
		q := denominator / common

		// Выводим результат в виде несократимой дроби "p/q"
		fmt.Printf("%d/%d\n", p, q)
	}

	// В Go нет необходимости явно возвращать 0 из main
}
